## ECDSSE的技术

### RocksDB

RocksDB支持一次获取多个k-v，还支持key范围查找。

### gRPC

RPC框架实际是提供了一套机制，使应用程序之间可以进行通信，而且也遵从server/client模型。使用的时候客户端调用server端提供的接口就像调用本地的函数一样。

#### gRPC的工作流程

1. gRPC首先要定义我们的接口文档
2. 编译proto文件，得到客户端存根文件（stub），这实际上就是远程read。与读取本地文件不同，远程read将参数打包成网络信息，并将此网络信息发送到远程服务器
3. 服务端（gRPC Server）实现第一步定义的接口并启动，这些接口的定义存在服务器的stub文件里面
4. 客户端借助stub文件调用服务器的函数，虽然客户端的函数调用由服务端实现，但是像在调用本地函数一样。

#### gRPCvsRestful API

##### 1.文档规范

##### 2.消息编码

gRPC使用`protobuf`进行消息编码，而Restful一般使用`JSON`进行编码

##### 3.传输协议

gRPC使用`HTTP/2`作为底层传输协议;RestFul则使用`HTTP`。

##### 4.传输性能

由于gRPC使用protobuf进行消息编码（即序列化），而经protobuf序列化后的消息体积很小（传输内容少，传输相对就快）；再加上HTTP/2协议的加持（HTTP1.1的进一步优化），使得gRPC的传输性能要优于Restful。

##### 5.传输形式

传输形式这块，gRPC最大的优势就是**支持流式传输**，传输形式具体可以分为四种（unary、client stream、server stream、bidirectional stream）.



### crypto++密码学库

里面都是加密算法

### openssl

保证两个应用程序间通信的保密性很可靠性，可在服务器端和用户端同时实现支持

### boost库

c++库，提供一些c++功能

### V2Ray

内核（V2Ray）用于实际的**网络交互、路由等针对网络数据的处理**，而外围的用户界面程序提供了方便直接的操作流程



## ECDSSE的操作

### 第一次打开项目

#### 打开server端

```
//执行makefile，编译生成可执行文件
make

//sdb是服务器数据放的地方，就是存index表的地方
./rpc_server ./sdb 4
```

#### 更新

```
新开一个终端做客户端
//test是客户端存状态表的地方
./update ./test 4
```

#### 搜索

```
在更新的那个终端
./search ./test 4
```





#### 问题

rocksDB设定的内存太小了，导致每次服务器拿数据都从硬盘里面拿，这样会增加搜索时间。



## 项目概述

方案：

更新阶段：

1. 客户端先检索客户端的更新状态表，查看新更新的关键字是否第一次更新
   1. 第一次更新就c=0，状态stc随机
   2. 否则c++，stc+1就是随机函数（kc+1，stc）
2. 把新状态存进客户端状态表
3. 然后对应加密索引和文档
4. 传到服务器

搜索阶段

1. 客户端通过需要查找的关键字得到当前的状态 stc和c
2. 上传token和状态给服务器
3. 用一个ID集存放被删除的ind，还有一个结果集
4. 从c到1把所有关于该关键字的更新记录全部放进结果集了，如果op是dele的就不放。

实现：

1. 建立rpc连接，首先是打开server端的rpc
   1. 它需要做的是文件数据的导入
   2. 首先新建一个grpc安全通道，其ip地址就是服务器地址
   3. 从本地读取需要加密存储的文件
   4. 循环write关键字文档对给服务器，这个期间客户端会产生更新token才可以weite给服务器
   5. 告诉服务器更新完了 write->finish
   6. 并且传递更新完胜的信号。status.ok()

2. 在更新这个过程中，客户端是将文件里面的明文关键字文档对加密，同时产生更新token的
3. 客户端打开的时候，就会把更新状态表放进内存，从rocksDB中

4. 搜索的过程就是，客户端产生搜索token，然后通过grpc的serch函数来搜索服务器端的数据库

5. 一开始server是wait（）状态，接收到请求，就会开始执行搜索函数，拿着request，进行搜索
6. 把搜索结果write到grpc通道里面。

